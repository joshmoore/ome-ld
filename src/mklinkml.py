#!/usr/bin/env python

import importlib
import inspect

def definitions():
    targets = [
            "affine_transform",
            "annotation",
            "annotation_ref",
            "arc",
            "arc_type",
            "basic_annotation",
            "bin_data",
            "bin_data_compression",
            "binary_file",
            "binning",
            "boolean_annotation",
            "channel",
            "channel_acquisition_mode",
            "channel_contrast_method",
            "channel_illumination_type",
            "channel_ref",
            "comment_annotation",
            "dataset",
            "dataset_ref",
            "detector",
            "detector_settings",
            "detector_type",
            "dichroic",
            "dichroic_ref",
            "double_annotation",
            "ellipse",
            "experiment",
            "experiment_ref",
            "experiment_value",
            "experimenter",
            "experimenter_group",
            "experimenter_group_ref",
            "experimenter_ref",
            "external",
            "external_compression",
            "filament",
            "filament_type",
            "file_annotation",
            "filter",
            "filter_ref",
            "filter_set",
            "filter_set_ref",
            "filter_type",
            "folder",
            "folder_ref",
            "generic_excitation_source",
            "image",
            "image_ref",
            "imaging_environment",
            "instrument",
            "instrument_ref",
            "label",
            "laser",
            "laser_laser_medium",
            "laser_pulse",
            "laser_type",
            "leader",
            "light_emitting_diode",
            "light_path",
            "light_source",
            "light_source_settings",
            "line",
            "list_annotation",
            "long_annotation",
            "manufacturer_spec",
            "map",
            "map_annotation",
            "marker",
            "mask",
            "metadata_only",
            "microbeam_manipulation",
            "microbeam_manipulation_ref",
            "microbeam_manipulation_value",
            "microscope",
            "microscope_type",
            "naming_convention",
            "numeric_annotation",
            "objective",
            "objective_correction",
            "objective_immersion",
            "objective_settings",
            "objective_settings_medium",
            "ome",
            "pixel_type",
            "pixels",
            "pixels_dimension_order",
            "plane",
            "plate",
            "plate_acquisition",
            "point",
            "polygon",
            "polyline",
            "project",
            "project_ref",
            "pump",
            "reagent",
            "reagent_ref",
            "rectangle",
            "reference",
            "rights",
            "roi",
            "roi_ref",
            "screen",
            "settings",
            "shape",
            "shape_fill_rule",
            "shape_font_family",
            "shape_font_style",
            "stage_label",
            "structured_annotations",
            "tag_annotation",
            "term_annotation",
            "text_annotation",
            "tiff_data",
            "timestamp_annotation",
            "transmittance_range",
            "type_annotation",
            "units_electric_potential",
            "units_frequency",
            "units_length",
            "units_power",
            "units_pressure",
            "units_temperature",
            "units_time",
            "well",
            "well_sample",
            "well_sample_ref",
            "xml_annotation",
        ]

    results = {}
    for mod in targets:
        x = importlib.import_module(f"ome_types._autogenerated.ome_2016_06.{mod}")
        for _, cls in inspect.getmembers(x, inspect.isclass):
            if cls.__module__.endswith(mod):
                results[cls.__name__] = cls
    return results


from jinja2 import Environment, FileSystemLoader, select_autoescape
from json import load
import yaml

env = Environment(
    loader=FileSystemLoader("."),
    autoescape=select_autoescape(),
)

kls_template = env.get_template("linkml.template")
enum_template = env.get_template("enum.template")


from pprint import pprint
import ome_types
import click
import enum
import os

OMEType = ome_types._mixins._base_type.OMEType
OMEMixin = ome_types._mixins._ome.OMEMixin
InstrumentMixin = ome_types._mixins._instrument.InstrumentMixin
KindMixin = ome_types._mixins._kinded.KindMixin
ShapeUnionMixin = ome_types._mixins._collections.ShapeUnionMixin
MapMixin = ome_types._mixins._map_mixin.MapMixin
ReferenceMixin = ome_types._mixins._reference.ReferenceMixin
SAMixin = ome_types._mixins._collections.StructuredAnnotationsMixin

mixins = (OMEType, OMEMixin, InstrumentMixin, KindMixin, ShapeUnionMixin, MapMixin, ReferenceMixin, SAMixin)

@click.command()
@click.argument('output_dir',
                type=click.Path(exists=True, file_okay=False, dir_okay=True, writable=True, readable=True, resolve_path=True))
def generate(output_dir):

    # https://github.com/tlambert03/ome-types/commits/fix-bugs/
    ome = ome_types._autogenerated.ome_2016_06.ome
    if False: # WIP
        s = ome.OME.json_schema()
        defs = sorted(s['definitions'])
        # Need to arrange name to class
    else:
        defs = definitions()

    enums = {}
    classes = {}
    for name, kls in defs.items():

        if name.endswith("Mixin") or name.endswith("Ref") or name in ("Union",):
            print(f"Skipping {name}...")
            continue

        elif type(kls) in (enum.EnumType, type):
            print(f"Processing enum: {name}...")
            schema = {
                "title": kls.__name__,
                "values": [x.value for x in kls],
            }
            enums[name] = schema

        else:
            template = kls_template
            schema = build_schema(kls)

            schema["tree_root"] = (name == "OME")

            bases = list(kls.__bases__)
            for x in mixins:
                try:
                    bases.remove(x)
                except:
                    pass

            if bases:
                print(f"Found bases: {','.join([str(x) for x in bases])}")
                if len(bases) > 1:
                    raise Exception("What?!")
                schema["base"] = bases[0].__name__
            else:
                schema["base"] = None


            print(f"Processing {name}...")
            classes[name] = schema

    with open(os.path.join(output_dir, "core.yaml"), "w") as o:
        o.write(template.render(classes=classes, enums=enums))


def build_schema(kls):

    schema = kls.schema()
    properties = {}  # Updated values to be placed in the schema
    mixins = {}

    for key, value in schema["properties"].items():

        # Extract mixins
        if key in ("id", "name"):
            mixins[key] = value
            continue

        # Choose new key
        key = key.replace("_ref", "")

        required = True
        name = None
        if "anyOf" in value:

            for item in value["anyOf"]:

                if item.get("type") == "null":
                    required = False
                    continue

                if name is not None:
                    raise Exception(f"More than one key: {item}")

                if "$ref" in item:
                    # Refs don't have types
                    name = item["$ref"]
                    name = name.split("/")[-1]
                    name = name.removesuffix("Ref")
                    continue

                name = item["type"]
                if name == "string":
                    if "pattern" in item:
                        name = item["pattern"]
                        # Most patterns are for IDs but there are some exceptions
                        if "urn:uuid" not in name:
                            name = name.split(":")
                            try:
                                name = name[3]
                            except:
                                raise Exception(item)
                    elif "format" in item:
                        if item["format"] == "date-time":
                            name = "datetime"
                        elif item["format"] == "color":
                            name = "string"  # FIXME
                        elif item["format"] == "binary":
                            name = "string"  # FIXME
                        else:
                            raise Exception(item)
                    elif len(item) > 1:  # Keys other than "string" that we need to handle
                        raise Exception(item)

                    # Strings handled
                    continue
                elif name in ("integer", "number", "boolean"):
                    # TODO: handle "minimum", etc
                    continue

                # Unhandled
                raise Exception(item)

            # Post-process the type value
            name = name.removesuffix("Ref")
            if name in ("Points", "FileName", "NamingConvention", "A00", "A01", "A02", "A10", "A11", "A12") or "urn:uuid" in name:
                name = "string"
            elif name == "number":
                name = "integer"



            # Overwrite values
            value["name"] = name
            value["required"] = required
            properties[key] = value

    schema["properties"] = properties
    return schema


if __name__ == "__main__":
    generate()
