#!/usr/bin/env python

import importlib
import inspect

def definitions():
    targets = [
            "affine_transform",
            "annotation",
            "annotation_ref",
            "arc",
            "arc_type",
            "basic_annotation",
            "bin_data",
            "bin_data_compression",
            "binary_file",
            "binning",
            "boolean_annotation",
            "channel",
            "channel_acquisition_mode",
            "channel_contrast_method",
            "channel_illumination_type",
            "channel_ref",
            "comment_annotation",
            "dataset",
            "dataset_ref",
            "detector",
            "detector_settings",
            "detector_type",
            "dichroic",
            "dichroic_ref",
            "double_annotation",
            "ellipse",
            "experiment",
            "experiment_ref",
            "experiment_value",
            "experimenter",
            "experimenter_group",
            "experimenter_group_ref",
            "experimenter_ref",
            "external",
            "external_compression",
            "filament",
            "filament_type",
            "file_annotation",
            "filter",
            "filter_ref",
            "filter_set",
            "filter_set_ref",
            "filter_type",
            "folder",
            "folder_ref",
            "generic_excitation_source",
            "image",
            "image_ref",
            "imaging_environment",
            "instrument",
            "instrument_ref",
            "label",
            "laser",
            "laser_laser_medium",
            "laser_pulse",
            "laser_type",
            "leader",
            "light_emitting_diode",
            "light_path",
            "light_source",
            "light_source_settings",
            "line",
            "list_annotation",
            "long_annotation",
            "manufacturer_spec",
            "map",
            "map_annotation",
            "marker",
            "mask",
            "metadata_only",
            "microbeam_manipulation",
            "microbeam_manipulation_ref",
            "microbeam_manipulation_value",
            "microscope",
            "microscope_type",
            "naming_convention",
            "numeric_annotation",
            "objective",
            "objective_correction",
            "objective_immersion",
            "objective_settings",
            "objective_settings_medium",
            "ome",
            "pixel_type",
            "pixels",
            "pixels_dimension_order",
            "plane",
            "plate",
            "plate_acquisition",
            "point",
            "polygon",
            "polyline",
            "project",
            "project_ref",
            "pump",
            "reagent",
            "reagent_ref",
            "rectangle",
            "reference",
            "rights",
            "roi",
            "roi_ref",
            "screen",
            "settings",
            "shape",
            "shape_fill_rule",
            "shape_font_family",
            "shape_font_style",
            "stage_label",
            "structured_annotations",
            "tag_annotation",
            "term_annotation",
            "text_annotation",
            "tiff_data",
            "timestamp_annotation",
            "transmittance_range",
            "type_annotation",
            "units_electric_potential",
            "units_frequency",
            "units_length",
            "units_power",
            "units_pressure",
            "units_temperature",
            "units_time",
            "well",
            "well_sample",
            "well_sample_ref",
            "xml_annotation",
        ]

    results = {}
    for mod in targets:
        x = importlib.import_module(f"ome_types._autogenerated.ome_2016_06.{mod}")
        for _, cls in inspect.getmembers(x, inspect.isclass):
            if cls.__module__.endswith(mod):
                results[cls.__name__] = cls
    return results


from jinja2 import Environment, FileSystemLoader, select_autoescape
from json import load
import yaml

env = Environment(
    loader=FileSystemLoader("."),
    autoescape=select_autoescape(),
)

kls_template = env.get_template("linkml.template")
enum_template = env.get_template("enum.template")


from pprint import pprint
import ome_types
import click
import enum
import os

OMEType = ome_types._mixins._base_type.OMEType

@click.command()
@click.argument('output_dir',
                type=click.Path(exists=True, file_okay=False, dir_okay=True, writable=True, readable=True, resolve_path=True))
def generate(output_dir):

    # https://github.com/tlambert03/ome-types/commits/fix-bugs/
    ome = ome_types._autogenerated.ome_2016_06.ome
    if False: # WIP
        s = ome.OME.json_schema()
        defs = sorted(s['definitions'])
        # Need to arrange name to class
    else:
        defs = definitions()

    for name, kls in defs.items():

        if name.endswith("Mixin"):
            print(f"Skipping {name}...")
            continue

        elif type(kls) in (enum.EnumType, type):
            print(f"Processing enum: {name}...")
            schema = {
                "title": kls.__name__,
                "values": [x.value for x in kls],
            }
            with open(os.path.join(output_dir, name + ".yaml"), "w") as o:
                o.write(enum_template.render(schema=schema))

        else:
            template = kls_template
            schema = build_schema(kls)

            bases = list(kls.__bases__)
            try:
                bases.remove(OMEType)
            except:
                pass

            if bases:
                print(f"Found bases: {','.join([str(x) for x in bases])}")
                if len(bases) > 1:
                    raise Exception("What?!")

            print(f"Processing {name}...")
            with open(os.path.join(output_dir, name + ".yaml"), "w") as o:
                o.write(template.render(schema=schema, bases=bases))


def build_schema(kls):

    # TODO: move more of the template if statements here
    schema = kls.schema()
    for key, value in schema["properties"].items():
        required = True
        name = None
        if "anyOf" in value:

            for item in value["anyOf"]:

                if item.get("type") == "null":
                    required = False
                    continue

                if name is not None:
                    raise Exception(f"More than one key: {item}")

                if "$ref" in item:
                    # Refs don't have types
                    name = item["$ref"]
                    name = name.split("/")[-1]
                    name = name.removesuffix("Ref")
                    continue

                name = item["type"]
                if name == "string":
                    if "pattern" in item:
                        name = item["pattern"]
                        # Most patterns are for IDs but there are some exceptions
                        if "urn:uuid" not in name:
                            name = name.split(":")
                            try:
                                name = name[3]
                            except:
                                raise Exception(item)
                    elif "format" in item:
                        if item["format"] == "date-time":
                            name = "datetime"
                        elif item["format"] == "color":
                            name = "FIXME:Color"
                        elif item["format"] == "binary":
                            name = "FIXME:Bin"
                        else:
                            raise Exception(item)
                    elif len(item) > 1:  # Keys other than "string" that we need to handle
                        raise Exception(item)

                    # Strings handled
                    continue
                elif name in ("integer", "number", "boolean"):
                    # TODO: handle "minimum", etc
                    continue

                # Unhandled
                raise Exception(item)

            # Overwrite values
            value["name"] = name
            value["required"] = required

    return schema


if __name__ == "__main__":
    generate()
